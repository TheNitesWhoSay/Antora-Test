= Notifications

== Primer

Getting data-change notifications from hist is as simple as adding a method to your tracked class:

[,cpp]
----
struct Item {
    std::string label = "";
    float value = 0.0f;
};

struct Npc_data {
    std::string name = "";
    int hitpoints = 0;
    std::vector<Item> inventory {};
};

REFLECT_PRIVATE(Item, label, value)
REFLECT_PRIVATE(Npc_data, name, hitpoints, inventory)

struct Npc : nf::tracked<Npc_data, Npc>
{
    Npc() : tracked(this) {}

    using inventory_path = NF_PATH(root->inventory);

    void element_added(inventory_path, std::size_t index)
    {
        std::cout << "new item: " << Json::out(read.inventory[index]) << '\n';
    }
};
----

Note: since ``Npc`` is given as a template param to tracked, hist can perform compile-time checks to see whether certain methods like ``element_added`` exist, and if and only if they're present, call them. Additionally because ``this`` is provided to tracked in the constructor, the call is _not_ polymorphic.

Now whenever elements are added to inventory this method will get called, e.g.

[,cpp]
----
npc()->inventory.append(Item{.name = "Bow", .value = 40.0f});
----

Undoing a removal or redoing an append would result in the same notification method being called.

Setting up a notification just requires that you know the signatures (TODO: Link to signatures below) and that you have some understanding of paths.

== Paths, Keys & Routes

* A *Path* describes the traversal from the root of a _class_ to one of its members/sub-members.
* A *Key* is a map-key or random-access index (e.g. array or vector index)
* A *Route* describes the traversal from the root of an _object_ (/instance of a class) to one of its members/sub-members - routes are just instances of paths wherein keys are known.

Paths & routes are used in creating notifications and defining sub-elements; behind the scenes... routes to elements are serialized when calling an op (e.g. operator= and append), and deserialized when rendering history or calling undo/redo.

Paths are just types, it's usually cleanest to create an alias for the paths you will be using with NF_PATH.

[,cpp]
----
struct Npc : nf::tracked<Npc_data, Npc>
{
    Npc() : tracked(this) {}

    using name_path = NF_PATH(root->name);
    using hitpoints_path = NF_PATH(root->hitpoints);
    using inventory_path = NF_PATH(root->inventory);
    using item_value_path = NF_PATH(root->inventory[0].value);
};
----

In this example, ``root`` is a static member of ``nf::tracked`` that you can use to create paths in an auto-complete friendly way. ``[0]`` here in inventory is merely syntactically representative of array access (and could in fact be any number), the path _types_ do _not_ store any key/index values.

An instance of a path (aka "route") _does_ have the keys/index values, so if you say, had a change notification on an items value and need to know which items value changed, you can get that:

[,cpp]
----
// TODO: Example
----

== Notification Signatures

Hist supports the "C.A.R.M.S." notifications - change, add, remove, move, and selection-update. Change is applicable to non-container fields, while add, remove, move, and selection update are only applicable to containers.

[,cpp]
----
void value_changed(PATH, OLD_VALUE, NEW_VALUE);
void element_added(PATH, INDEX);
void element_removed(PATH, INDEX);
void element_moved(PATH, OLD_INDEX, NEW_INDEX);
void selections_changed(PATH);
void after_action(std::size_t action_index);
----

Unless you modified the index types as in TODO: link, they're going to be of type std::size_t, the values are the type of the actual value changed, and the paths are those you create with NF_PATH.

TODO: usage example for above signatures
